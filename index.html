<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SandDrawing</title>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="script.js"></script>
<!-- vertex shader -->
<script id="2d-vertex-shader" type="x-shader/x-vertex">
  attribute vec2 a_position;
  attribute vec2 a_texCoord;

  uniform vec2 u_resolution;
  uniform float u_flipY;

  varying vec2 v_texCoord;

  void main() {
    // convert the rectangle from pixels to 0.0 to 1.0
    vec2 zeroToOne = a_position / u_resolution;

    // convert from 0->1 to 0->2
    vec2 zeroToTwo = zeroToOne * 2.0;

    // convert from 0->2 to -1->+1 (clipspace)
    vec2 clipSpace = zeroToTwo - 1.0;

    gl_Position = vec4(clipSpace * vec2(1, u_flipY), 0, 1);

    // pass the texCoord to the fragment shader
    // The GPU will interpolate this value between points.
    v_texCoord = a_texCoord;
  }
</script>
<script id="erosion-shader" type="x-shader/x-fragment">
  precision mediump float;

  // our texture
  uniform sampler2D u_image;
  uniform vec2 u_textureSize;
  uniform float u_stage;
  uniform vec2 u_mouse;
  uniform vec2 u_prev_mouse;

  // the texCoords passed in from the vertex shader.
  varying vec2 v_texCoord;

  vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
  vec2 mouseCs = u_mouse.xy * onePixel;
  vec3 grains;
  vec3 neighbors[8];
  float angle;

  float getMouseAngle() {
    return atan(u_mouse.y - u_prev_mouse.y, u_mouse.x - u_prev_mouse.x);
  }

  vec3 getSandData(float xoff, float yoff) {
    return texture2D(u_image, v_texCoord + vec2(onePixel.x*xoff, onePixel.y*yoff)).xyz;
  }

  float getSandDataFromCoords(vec2 coords) {
    return texture2D(u_image, onePixel*coords).x;
  }

  bool isTooSteep(float x, float y) {
    if (x > y) {
      return atan((x-y)) > 1.0;
    }
    else {
      return false;
    }
  }

  void getNeighbors() {
    neighbors[0] = getSandData(-1.0, -1.0);
    neighbors[1] = getSandData(-1.0, 0.0);
    neighbors[2] = getSandData(-1.0, 1.0);
    neighbors[3] = getSandData(0.0, -1.0);
    neighbors[4] = getSandData(0.0, 1.0);
    neighbors[5] = getSandData(1.0, -1.0);
    neighbors[6] = getSandData(1.0, 0.0);
    neighbors[7] = getSandData(1.0, 1.0);
  }

  void receiveFromLastRound() {
    float receiveAmount = 0.0;
    for (int i=0;i<8;i++) {
      if (isTooSteep(neighbors[i].z, grains.x)) {
        receiveAmount += neighbors[i].y;
      }
    }
    grains.x += receiveAmount;
  }

  float getDistributeAmount(float neighborValue) {
    float distrAmount = 0.0;
    if (isTooSteep(grains.x, neighborValue)) {
      return (grains.x - neighborValue) * 0.2;
    }
    else {
      return 0.0;
    }
  }

  float getTotalDistributeAmount() {
    float n = 0.0;
    float distrAmount;
    float totalDistrAmount = 0.0;
    for (int i=0;i<8;i++) {
      distrAmount = getDistributeAmount(neighbors[i].x);
      if (distrAmount > 0.0) {
        n += 1.0;
        totalDistrAmount += distrAmount;
      }
    }
    if (n > 0.0) {
      grains.x -= totalDistrAmount / n;
      return totalDistrAmount / n;
    }
    else {
      return 0.0;
    }
  }

  float getDistanceFromOrigin(vec2 vector) {
    return sqrt(pow(vector.x, 2.0) + pow(vector.y, 2.0));
  }

  bool isReceiving(vec2 coord) {
    return getDistanceFromOrigin(u_mouse-coord) < getDistanceFromOrigin(u_prev_mouse-coord);
  }

  bool isClosestReceiving(vec2 receivCoord, vec2 giveCoord) {
    float compDistance = getDistanceFromOrigin(receivCoord - giveCoord);
    if (compDistance > getDistanceFromOrigin(giveCoord-compDistance+vec2(0, 1))) {
      return false;
    } else if (compDistance > getDistanceFromOrigin(giveCoord-compDistance+vec2(0, -1))) {
      return false;
    } else if (compDistance > getDistanceFromOrigin(giveCoord-compDistance+vec2(1, -1))) {
      return false;
    } else if (compDistance > getDistanceFromOrigin(giveCoord-compDistance+vec2(1, 0))) {
      return false;
    } else if (compDistance > getDistanceFromOrigin(giveCoord-compDistance+vec2(1, 1))) {
      return false;
    } else if (compDistance > getDistanceFromOrigin(giveCoord-compDistance+vec2(-1, -1))) {
      return false;
    } else if (compDistance > getDistanceFromOrigin(giveCoord-compDistance+vec2(-1, 0))) {
      return false;
    } else if (compDistance > getDistanceFromOrigin(giveCoord-compDistance+vec2(-1, 1))) {
      return false;
    } else {
      return true;
    }
  }

  float getDisplacementAmount() {
    float amount = 0.0;
    float count = 0.0;
    for (float i=0.0;i<15.0;i++) {
      for (float j=0.0;j<15.0;j++) {
        float distance = floor(getDistanceFromOrigin(vec2(i,j)));
        if (distance < 15.0) {
          if (isClosestReceiving(v_texCoord/onePixel, u_mouse+vec2(i, j))) {
            amount += getSandDataFromCoords(u_mouse+vec2(i, j));
            count++;
          } else if (isClosestReceiving(v_texCoord/onePixel, u_mouse+vec2(i, -j))) {
            amount += getSandDataFromCoords(u_mouse+vec2(i, -j));
            count++;
          } else if (isClosestReceiving(v_texCoord/onePixel, u_mouse+vec2(-i, j))) {
            amount += getSandDataFromCoords(u_mouse+vec2(-i, j));
            count++;
          } else if (isClosestReceiving(v_texCoord/onePixel, u_mouse+vec2(-i, -j))) {
            amount += getSandDataFromCoords(u_mouse+vec2(-i, -j));
            count++;
          }
        }
      }
    }
    return amount / count;
  }

  void main() {
    grains = texture2D(u_image, v_texCoord).xyz;
    angle = getMouseAngle();
    if (u_stage == -2.0) {
      float value = texture2D(u_image, v_texCoord).x;
      gl_FragColor = vec4(value, 0.0, 0.0, 0.0);
    }
    else if (u_stage == 0.0) {
      float distance = floor(sqrt(pow((mouseCs.x-v_texCoord.x)/onePixel.x, 2.0) + pow((mouseCs.y-v_texCoord.y)/onePixel.y, 2.0)));
      if(distance < 15.0) {
        gl_FragColor = texture2D(u_image, v_texCoord);
        gl_FragColor.x = 0.0;
      }
      else if (distance == 15.0 && isReceiving(v_texCoord/onePixel)) {
        gl_FragColor.x += getDisplacementAmount();
      } else {
        gl_FragColor = texture2D(u_image, v_texCoord);
      }
    }
    else if (u_stage == 1.0) {
      getNeighbors();
      receiveFromLastRound();
      float prevValue = grains.x;
      float distribute = getTotalDistributeAmount();
      if (distribute == 0.0) {
        prevValue = 0.0;
      }
      // x = amount of sand, y = amount to be distributed to all receivers
      // z = previous amout that calculated the distribution
      gl_FragColor = vec4(grains.x, distribute, prevValue, 0.5);
    }
    else {
      float value = texture2D(u_image, v_texCoord).x;
      gl_FragColor = vec4(1.0-value, 1.0, 1.0, 0.5);
    }
  }
</script>
</head>
<body>
  <canvas id="canvas"></canvas>
</body>
</html>