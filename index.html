<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SandDrawing</title>
<style>
  body, canvas {
    margin: 0px;
    padding: 0px;
    background-color: black;
  }
  canvas {
    margin: auto;
  position: absolute;
  top: 0; left: 0; bottom: 0; right: 0;
  }
</style>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="Fingertip.js"></script>
<script type="text/javascript" src="TouchUI.js"></script>
<script type="text/javascript" src="script.js"></script>
<!-- vertex shader -->
<script id="2d-vertex-shader" type="x-shader/x-vertex">
  attribute vec2 a_position;
  attribute vec2 a_texCoord;

  uniform vec2 u_resolution;
  uniform float u_flipY;

  varying vec2 v_texCoord;

  void main() {
    // convert the rectangle from pixels to 0.0 to 1.0
    vec2 zeroToOne = a_position / u_resolution;

    // convert from 0->1 to 0->2
    vec2 zeroToTwo = zeroToOne * 2.0;

    // convert from 0->2 to -1->+1 (clipspace)
    vec2 clipSpace = zeroToTwo - 1.0;

    gl_Position = vec4(clipSpace * vec2(1, u_flipY), 0, 1);

    // pass the texCoord to the fragment shader
    // The GPU will interpolate this value between points.
    v_texCoord = a_texCoord;
  }
</script>
<script id="erosion-shader" type="x-shader/x-fragment">
  precision mediump float;

  // our texture
  uniform sampler2D u_image;
  uniform vec2 u_textureSize;
  uniform float u_stage;
  uniform vec4 u_touchlocations[8];

  // the texCoords passed in from the vertex shader.
  varying vec2 v_texCoord;

  vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
  vec3 grains;
  vec3 neighbors[8];
  const float mouseSize = 8.0;
  const float steepVal = 0.15;

  vec3 getSandData(float xoff, float yoff) {
    return texture2D(u_image, v_texCoord + vec2(onePixel.x*xoff, onePixel.y*yoff)).xyz;
  }

  float getSandDataFromCoords(vec2 coords) {
    return texture2D(u_image, onePixel*coords).x;
  }

  bool isTooSteep(float x, float y) {
    if (x > y) {
      return atan((x-y)) > steepVal;
    }
    else {
      return false;
    }
  }

  void getNeighbors() {
    neighbors[0] = getSandData(-1.0, -1.0);
    neighbors[1] = getSandData(-1.0, 0.0);
    neighbors[2] = getSandData(-1.0, 1.0);
    neighbors[3] = getSandData(0.0, -1.0);
    neighbors[4] = getSandData(0.0, 1.0);
    neighbors[5] = getSandData(1.0, -1.0);
    neighbors[6] = getSandData(1.0, 0.0);
    neighbors[7] = getSandData(1.0, 1.0);
  }

  float receiveFromLastRound() {
    float receiveAmount = 0.0;
    for (int i=0;i<8;i++) {
      if (isTooSteep(neighbors[i].z, grains.x)) {
        receiveAmount += neighbors[i].y;
      }
    }
    return receiveAmount;
  }

  float getDistributeAmount(float neighborValue) {
    float distrAmount = 0.0;
    if (isTooSteep(grains.x, neighborValue)) {
      return (grains.x - neighborValue) * 0.2;
    }
    else {
      return 0.0;
    }
  }

  float getTotalDistributeAmount() {
    float n = 0.0;
    float distrAmount;
    float totalDistrAmount = 0.0;
    for (int i=0;i<8;i++) {
      distrAmount = getDistributeAmount(neighbors[i].x);
      if (distrAmount > 0.0) {
        n++;
        totalDistrAmount += distrAmount;
      }
    }
    if (n > 0.0) {
      grains.x = grains.x - totalDistrAmount;
      return totalDistrAmount / n;
    }
    else {
      return 0.0;
    }
  }

  float getDistanceFromOrigin(vec2 vector) {
    return sqrt(pow(vector.x, 2.0) + pow(vector.y, 2.0));
  }

  bool isReceiving(vec2 coord, vec2 mouseCoord, vec2 prevMouseCoord) {
    return getDistanceFromOrigin(mouseCoord-coord) < getDistanceFromOrigin(prevMouseCoord-coord);
  }

  float getDisplacementAmount(float angle, vec2 nextMouse, vec2 prevMouse) {
    float amount = 0.0;
    for (float i=-mouseSize-5.0;i<mouseSize+5.0;i++) {
      if (i!=0.0) {
        float r = i;
        if (cos(angle) < 1.0) {
          r = r * sqrt(2.0);
        }
        float toX = cos(angle) * r;
        float toY = sin(angle) * r;
        if (toX > 0.0) {
          toX += 0.5;
        }
        if (toY > 0.0) {
          toY += 0.5;
        }
        toX = floor(toX);
        toY = floor(toY);
        vec2 fetchCoord = v_texCoord/onePixel + vec2(toX,toY);
        if (
          (floor(getDistanceFromOrigin(nextMouse - fetchCoord)) < mouseSize) || 
          (floor(getDistanceFromOrigin(prevMouse - fetchCoord)) < mouseSize)
        ) {
          amount += getSandDataFromCoords(fetchCoord);
        }

      }
    }
    return amount;
  }

  float undulate(float x)
  {
      if(x < -0.4)
      {
          return 0.15 + 2.857 * (x + 0.75)*(x + 0.75);
      }
      else if(x < 0.4)
      {
          return 0.95 - 2.8125 * (x*x);
      }
      else
      {
          return 0.26 + 2.666 * (x - 0.7)*(x - 0.7);
      }
  }
 
  float marble(vec2 p)
  {
      float PI = 3.1415;
      float s = 0.25;
      float a = 2.0;
      
      // this computes 3 octaves of turbulence
      vec4 t1 = 1.0*vec4(p, 0.2, 0.2);
      vec4 t2 = 0.5*vec4(p, 0.2, 0.2);
      vec4 t3 = 0.25*vec4(p, 0.2, 0.2);
   
      float m = undulate(sin(p.y*2.0*PI + a*(t1.x + t2.x + t3.x)));
     
      return m;
  }
 
  void main() {
    grains = texture2D(u_image, v_texCoord).xyz;
    if (u_stage == -2.0) {
      float val = marble(v_texCoord);
      gl_FragColor = vec4(val, 0.0, 0.0, 1.0);
    }
    else if (u_stage == -1.0) {
      //Receive from last erosions stage
      getNeighbors();
      float received = receiveFromLastRound();
      gl_FragColor = vec4(grains.x+received, 0.0, 0.0, 1.0);
    }
    else if (u_stage == 0.0) {
      //Displacement stage
      float sandValue = texture2D(u_image, v_texCoord).x;
      for(int i=0;i<8;i++) {
        if (u_touchlocations[i].x > 0.0) {
          vec2 prevMouse = vec2(float(u_touchlocations[i].x), float(u_touchlocations[i].y));
          vec2 nextMouse = vec2(float(u_touchlocations[i].z), float(u_touchlocations[i].w));
          float distance = floor(getDistanceFromOrigin(nextMouse-v_texCoord/onePixel));
          if(distance < mouseSize) {
            sandValue = 0.0;
          }
          else if (distance == mouseSize && isReceiving(v_texCoord/onePixel, nextMouse, prevMouse)) {
            vec2 curr = v_texCoord/onePixel;
            float angle = atan(nextMouse.y-prevMouse.y,nextMouse.x-prevMouse.x);
            sandValue += getDisplacementAmount(angle, nextMouse, prevMouse);
          }
        }
      }
      gl_FragColor = vec4(sandValue, 0.0, 0.0, 1.0);
    }
    else if (u_stage == 1.0) {
      getNeighbors();
      float prevValue = grains.x;
      float distribute = getTotalDistributeAmount();
      // x = amount of sand, y = amount to be distributed to all receivers
      // z = previous amout that calculated the distribution
      gl_FragColor = vec4(grains.x, distribute, prevValue, 0.5);
    }
    else {
      float value = texture2D(u_image, v_texCoord).x;
      vec4 baseColor = vec4(0.968, 0.83, 0.605, 1.0);
      //1 pitää olla lähes musta
      //0 pitää olla valkoinen
      if (value == 0.0) {
        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
      } else {
        gl_FragColor = vec4(0.968-(0.968*value), 0.83-(0.83*value), 0.605-(0.605*value), 1.0);
      }
      
    }
  }
</script>
</head>
<body>
  <canvas id="canvas"></canvas>
</body>
</html>